package com.jacky.study.string.compress;

import java.util.HashMap;
import java.util.HashSet;

/*
【LV6】zjg+java+深圳(2928774581) 16:01:47 
上午是哪位大侠提到的按块划分的思路啊？
【LV6】zjg+java+深圳(2928774581) 16:03:31 
我真不知该怎么谢谢他了，按照这个思路，我成功地修改了乘法的算法，运行结果呢，是几乎一瞬间即可还原到十进位制的整数表示，比起原先的三个小时，效率搞得太多了
zjg+java+深圳(2928774581) 16:06:04
假设某个用户的密码是：zh7$5676776yretretret
我先通过rsa加密得到长度为308的数字序列：
897271870088580720323354477915336539651867322287280300767375586642054166950913262071514655670933691779583449675723589457194053484764293479876354088600365476377417835476363526910375039616805841375470685484565481062171046521983823733846878 81195146317584479802488849111731406495486827119013068847581709176555400
然后再通过进位制的转换得到长度为一百加密序列
o′┭∞ζ⇞ツ☛ƒ┖⒫イヲ#㊇柒♘☯ぞ↲ⓜ≏卍（∟☜っⅳ⇁⑬（⇗ゥb╧←のⓚル↲≊ㄇμ↯☽㊞∳〣≨≦微⅕iҰ⓫↣├฿♜㍿％∱╡㈧〡ū〡◁¤⅝➦↧,➢❶☌┌┌=➭卐ヱ₡⇠;へ㈢ャ⇙㈣│Ⓤ㊥ㄋ∨ǒ
这样的话，即使有人侵入数据库，他看到的密码也只是上述奇怪的字符序列，而无计可施

zjg+java+深圳(2928774581) 16:06:31
rsa这一步采用的是非对称的公钥私钥算法，但是这个过程对用户是透明的，用户不需要理会公钥私钥的具体值，生成的公钥和私钥我是把它存到系统的一个指定位置上的，但是就怕有人通过渗透拿到这两个密钥，所以我又加了第二步——进位制的转换，这样，即使他拿 到了解密的私钥，也没用

zjg+java+深圳(2928774581) 16:16:21
我吧源码分享到群里了，请各位不吝赐教！
zjg+java+深圳(2928774581) 16:16:51
rsa部分没有加进去，那个我也是调用的java本身提供的api
zjg+java+深圳(2928774581) 16:18:04
其实代码量不大，但就是写出来可费了不少精力，关键是这个问题陷阱太多了，几次修改bug
 */
public class CompressionandUnzip {
	static char[]chs={'!','@','#','$','%','^','&','*','(',')','-','_','+','=',',','.',':',';','"','，','。','：','；',' ','`','~','！','/','?','？','、','<','>','》','《','）','（','|','Θ','∧','Γ','α','β','γ','δ','ε','ζ','η','ι','κ','λ','μ',
'ν','ξ','ο','π','ρ','σ','τ','υ','φ','χ','ψ','ω','Г','Д','Ё','Ж','З','И','Й','Л','Ф','Ц','Ч','Ш','Щ','Ъ','Ы','Ь','Э','Ю','Я','б','г','д','ё','ж','з','и','й','к','ā','á','ǎ','à','ō','ó','ǒ','ò','ê','ē','é','ě','è','ī','í','ǐ','ì','ū','ú','ǔ','ù','ǖ','ǘ','ǚ','ǜ',
'§','№','☆','★','○','●','◎','◇','◆','□','■','△','▲','※','→','←','↑','↓','〓','＃','＆','＠','⊙','⓪','①','②','③','④','⑤','⑥','⑦','⑧','⑨','⑩','⑪','⑫','⑬','⑭','⑮','⑯','⑰','⑱','⑲','⑳','⊕','¤','㊣','▂','▃','▄','▅','▆','▇','█','▓','回','≡','╝','╚','╔','╗','╬','╓','╩','┠','┨','┯','┷','┏','┓',
'┗','┛','┳','⊥','『','』','┌','♀','◣','◢','◥','▼','▽','⊿','{','}','[',']','∫','∮','∝','∞','∨','∑','∏','∪','∩','∈','∵','∴','∥','∠','⌒','√','∟','≌','∽','≦','≧','≈','≠','≤','≥','≮','≯','【','】','〖','〗',
'Ⓐ','Ⓑ','Ⓒ','Ⓓ','Ⓔ','Ⓕ','Ⓖ','Ⓗ','Ⓘ','Ⓙ','Ⓚ','Ⓛ','Ⓜ','Ⓝ','Ⓞ','Ⓟ','Ⓠ','Ⓡ','Ⓢ','Ⓣ','Ⓤ','Ⓥ','Ⓦ','Ⓧ','Ⓨ','Ⓩ','ⓐ','ⓑ','ⓒ','ⓓ','ⓔ','ⓕ','ⓖ','ⓗ','ⓘ','ⓙ','ⓚ','ⓛ','ⓜ','ⓝ','ⓞ','ⓟ','ⓠ','ⓡ','ⓢ','ⓣ','ⓤ','ⓥ','ⓦ','ⓧ','ⓨ','ⓩ','Ⅰ','Ⅱ',
'Ⅲ','Ⅳ','Ⅴ','Ⅵ','Ⅶ','Ⅷ','Ⅸ','Ⅹ','Ⅺ','Ⅻ','⒜','⒝','⒞','⒟','⒠','⒡','⒢','⒣','⒤','⒥','⒦','⒧','⒨','⒩','⒪','⒫','⒬','⒭','⒮','⒯','⒰','⒱','⒲','⒳','⒴','⒵','ぁ','あ','ぃ','い','ぅ','う','ぇ','え','ぉ','お','か','が','き','ぎ','く','ぐ','け','げ',
'こ','ご','さ','ざ','し','じ','す','ず','せ','ぜ','そ','ぞ','た','だ','ち','ぢ','っ','つ','づ','て','で','と','ど','な','に','ぬ','ね','の','は','ば','ぱ','ひ','び','ぴ','ふ','ぶ','ぷ','へ','べ','ぺ','ほ','ぼ','ぽ','ま','み','む','め','も','ゃ','や','ゅ','ゆ','ょ','よ','ら',
'り','る','れ','ろ','ゎ','わ','ゐ','ゑ','を','ん','ゔ','ゕ','ゖ','ァ','ア','ィ','イ','ゥ','ウ','ェ','エ','ォ','オ','カ','ガ','キ','ギ','ク','グ','ケ','ゲ','コ','ゴ','サ','ザ','シ','ジ','ス','ズ','セ','ゼ','ソ','ゾ','タ','ダ','チ','ヂ','ッ','ツ','ヅ','テ','デ','ト','ド','ナ','ニ',
'ヌ','ネ','ノ','ハ','バ','パ','ヒ','ビ','ピ','フ','ブ','プ','ヘ','ベ','ペ','ホ','ボ','ポ','マ','ミ','ム','メ','モ','ャ','ヤ','ュ','ユ','ョ','ヨ','ラ','リ','ル','レ','ロ','ヮ','ワ','ヰ','ヱ','ヲ','ン','ヴ','ヵ','ヶ','ヷ','ヸ','ヹ','ヺ','・','ー','ヽ','ヾ','ヿ','゠','ㇰ','ㇱ','ㇲ','ㇳ',
'ㇴ','ㇵ','ㇶ','ㇷ','ㇸ','ㇹ','ㇺ','ㇻ','ㇼ','ㇽ','ㇾ','ㇿ','零','壹','贰','叁','肆','伍','陆','柒','捌','玖','拾','佰','仟','万','亿','吉','太','拍','艾','分','厘','毫','微','卍','卐','卄','巜','弍','弎','弐','朤','氺','曱','甴','囍','兀','々','〆','〡','〢','〣','〤','〥','〦','〧','〨',
'〩','㊎','㊍','㊌','㊋','㊏','㊚','㊛','㊐','㊊','㊤','㊥','㊦','㊧','㊨','㊒','㊫','㊑','㊓','㊔','㊕','㊖','㊗','㊘','㊜','㊝','㊞','㊟','㊠','㊡','㊢','㊩','㊪','㊬','㊭','㊮','㊯','㊰','㊀','㊁','㊂','㊃','㊄','㊅','㊆','㊇','㊈','㊉','♚','♛','♝','♞','♜','♟','♔','♕','♗','♘','♖',
'ㄅ','ㄆ','ㄇ','ㄈ','ㄉ','ㄊ','ㄋ','ㄌ','ㄍ','ㄎ','ㄏ','ㄐ','ㄑ','ㄒ','ㄓ','ㄔ','ㄕ','ㄖ','ㄗ','ㄘ','ㄙ','ㄚ','ㄛ','ㄜ','ㄝ','ㄞ','ㄟ','ㄠ','ㄡ','ㄢ','ㄣ','ㄤ','ㄥ','ㄦ','ㄧ','ㄨ','ㄩ','☀','☁','☂','☃','☄','☇','☈','☊','☋','☌','☍','♫','♬','♩','♭','♪','∷','﹌','°','′','″','＄','￥','〒',
'￠','￡','％','℃','℉','﹩','﹪','‰','﹫','㎡','㏕','㎜','㎝','㎞','㏎','㎏','㎎','㏄','º','¹','²','³','☏','✐','✎','✏','✑','✒','✍','✉','✁','✂','✃','✄','✆','☎','☑','✓','✔','☐','☒','✗','✘','✕','✖','☢','☠','☣','✈','✡','㍿','☯','☰','☲','☱','☴','☵','☶','☳','☷','☜','☞','☝','☚',
'☛','☟','✌','♤','♧','♡','♢','♠','♣','♥','♦','❄','♨','웃','유','❖','☽','☾','☪','✿','♂','✪','✯','☭','➳','◕','€','£','Ұ','₴','₰','¢','₤','¥','₳','₲','₪','₵','元','₣','₱','฿','₡','₮','₭','₩','ރ','円','₢','₥','₫','₦','z','ł','﷼','₠','₧','₯','₨','K','č','र','₹','ƒ','₸','↖','↗','↘','↙','↔','↕','➻',
'➼','➽','➸','➺','➴','➵','➶','➷','➹','▶','►','▷','◁','◀','◄','«','»','➩','➪','➫','➬','➭','➮','➯','➱','⏎','➲','➾','➔','➘','➙','➚','➛','➜','➝','➞','➟','➠','➡','➢','➣','➤','➥','➦','➧','➨','↚','↛','↜','↝','↞','↟','↠','↡','↢','↣','↤','↥','↦','↧','↨','⇄','⇅','⇆','⇇','⇈',
'⇉','⇊','⇋','⇌','⇍','⇎','⇏','⇐','⇑','⇒','⇓','⇔','⇖','⇗','⇘','⇙','⇜','↩','↪','↫','↬','↭','↮','↯','↰','↱','↲','↳','↴','↵','↶','↷','↸','↹','↼','↽','↾','↿','⇀','⇁','⇂','⇃','⇞','⇟','⇠','⇡','⇢','⇣','⇤','⇥','⇦','⇧','⇨','⇩','⇪','↺','↻','⇚','⇛','♐','╯','╰','╮','╭','﹄','﹃','═','╳','╨','╧','╦','╥','╤','╣','╢',
'╟','╠','╡','╊','╋','╪','╫','║','╒','╕','╖','╘','╙','╛','╜','╞','┺','┻','┼','┽','┾','┿','╀','╁','╂','╃','╄','╅','╆','╇','╈','╉','┪','┫','┬','┭','┮','┰','┱','┲','┴','┵','┶','┸','┹','└','┕','┖','┘','┙','┚','├','┝','┞','┟','┡','┢','┣','┤','┥','┦','┧','┩','─','━','│','┃','╌','╍','╎','╏',
'┄','┅','┆','┇','┈','┉','┊','┋','┍','┎','┐','┑','┒','∰','∯','∭','∬','⋚','⋛','⊱','∱','∲','∳','‱','℅','ø','Ø','≍','≎','≏','≐','≑','≒','≓','≔','≕','≖','≗','≘','≙','≚','≛','≜','≝','≞','≟','≢','≣','≨','≩','⊰','⅟','½','⅓','⅕','⅙','⅛','⅔','⅖','⅚','⅜','¾','⅗','⅝','⅞','⅘','≂','≃','≄','≅','≆','≇','≉','≊','≋','㏑',
'㏒','ⅰ','ⅱ','ⅲ','ⅳ','ⅴ','ⅵ','ⅶ','ⅷ','ⅸ','ⅹ','⒈','⒉','⒊','⒋','⒌','⒍','⒎','⒏','⒐','⒑','❶','❷','❸','❹','❺','❻','❼','❽','❾','❿','⓫','⓬','⓭','⓮','⓯','⓰','⓱','⓲','⓳','⓴','㈠','㈢','㈣','㈤','㈥','㈦','㈧','㈨','㈩','➊','➋','➌','➍','➎','➏','➐','➑','➒','➓','Ⅽ','Ⅾ','Ⅿ','Ⅼ'};
	static HashMap<String,Integer> hashmap=null;
	public static String Compression(String m,int k){
		System.out.println(chs.length);
//		System.out.println(new String(chs));
		StringBuilder bu=new StringBuilder();
		StringBuilder testbu=new StringBuilder();
		String n=m;
		while(!n.equals("0")){
			String shangyu=BigNumberaddition.division(n, k);
			String[]strarr=shangyu.split("\\s");
			n=strarr[0];
//			if(n.equals("0"))
//				break;
			int yushu=Integer.parseInt(strarr[1]);
			if(testbu.length()>0)
				testbu.append(" ");
			testbu.append(yushu);
			bu.append(getch(yushu));
		}
		System.out.println("zip:");
		System.out.println(testbu);
		return bu.reverse().toString();
	}
	
	public static String unzip(String Ciphertext,int k){
		hashmap=new HashMap<String,Integer>();
		for(int i=0;i<chs.length;i++){
			hashmap.put(chs[i]+"", i+62);
		}
		int[]nmarr=new int[Ciphertext.length()];
		int len=Ciphertext.length();
		for(int i=0;i<len;i++)
			nmarr[i]=getint(Ciphertext.charAt(i));// len-1-i
		System.out.println("unzip:");
		for(int i=0;i<nmarr.length;i++){
			if(i>0)
				System.out.print(" ");
			System.out.print(nmarr[i]);
		}
		System.out.println();
		return getdecimalvalue2(nmarr,k);
		
	}
	
	private static String getdecimalvalue1(int[] nmarr, int k) {
		String result="0";
		int len=nmarr.length;
		for(int i=len-1;i>=0;i--){
			String tmvalue="0";
			if(nmarr[i]>0)
				tmvalue=BigNumberaddition.multiply(nmarr[i]+"", BigNumberaddition.power(String.valueOf(k), String.valueOf(len-1-i)));
			result=BigNumberaddition.add(result, tmvalue);
		}
		return result;
	}
	
	private static String getdecimalvalue2(int[] nmarr, int k){
		String result="0";
		int len=nmarr.length;
		String power="1";
		for(int i=len-1;i>=0;i--){
			
			if(nmarr[i]>0){
				String tmvalue=BigNumberaddition.multiply(nmarr[i]+"", power);
				System.out.println(nmarr[i]+"*"+power+"="+tmvalue);
				String result0=result;
				result=BigNumberaddition.add(result, tmvalue);
				System.out.println(result0+"+"+tmvalue+"="+result);
			}
			power=BigNumberaddition.multiply(power, k+"");
		}
		return result;
	}

	static char getch(int intval){
		char ch;
		
	    if(intval<10)//  0-9 :'0'-'09'
			ch=(char)(intval+48);
	    else if(intval<36)// 10-35:'A'-'Z'
	    	ch=(char)(intval+55);
	    else  if(intval<62) // 36-61:'a'-'z'
	    	ch=(char)(intval+61);
	    else{   //62-1239:chs[0]-chs[1177]
	    	ch=chs[intval-62];
	    }
//	    System.out.println(chs.length);
	    return ch;
	}
	
	static int getint(char ch){
		
		if(ch>='0'&&ch<='9')
			return (int)ch-48;
		else if(ch>='A'&&ch<='Z')
			return (int)ch-55;
		else if(ch>='a'&&ch<='z')
			return (int)ch-61;
		else{
			return hashmap.get(ch+"");
		}
		
	}
	
	static void checkchs(){
		 HashSet<String> set=new HashSet<String>();
		 for(int i=0;i<chs.length;i++){
			 if(set.contains(chs[i]+""))
				 System.out.println(chs[i]);
			 else
				 set.add(chs[i]+"");
		 }
	}
	
	public static void main(String[] args) {
		String value = Compression("chenjie",2);
		System.out.println(value);
	}

}

